import logging
import asyncio
from typing import List, Optional

import httpx
from packaging.version import parse as parse_version
from packaging.specifiers import SpecifierSet
from asyncio_throttle import Throttler

from src.models import Vulnerability

logger = logging.getLogger(__name__)

vulnerability_api_throttler = Throttler(rate_limit=10)

async def check_osv_vulnerabilities(
    package_name: str,
    current_version: str
) -> List[Vulnerability]:
    """
    Checks the OSV.dev database for known vulnerabilities affecting a package version.
    """
    vulnerabilities: List[Vulnerability] = []
    url = f"https://api.osv.dev/v1/query"
    payload = {
        "package": {
            "name": package_name,
            "ecosystem": "PyPI"
        },
        "version": current_version
    }

    async with vulnerability_api_throttler:
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(url, json=payload, timeout=10)
                response.raise_for_status()
                data = response.json()
                vulns = data.get("vulns", [])

                if vulns:
                    logger.info(f"OSV Checker: Found {len(vulns)} advisories for {package_name} ({current_version}) on OSV.dev.")
                    for vuln in vulns:
                        severity = "UNKNOWN"
                        if "severity" in vuln and isinstance(vuln["severity"], list) and vuln["severity"]:
                            severity = vuln["severity"][0].get("type", "UNKNOWN")
                        elif "database_specific" in vuln and "severity" in vuln["database_specific"]:
                            severity = vuln["database_specific"]["severity"]

                        extracted_advisory_url = "N/A"
                        references = vuln.get("references", [])
                        for ref in references:
                            if ref.get("type") == "WEB" and ref.get("url"):
                                extracted_advisory_url = ref["url"]
                                break
                            elif ref.get("url"):
                                extracted_advisory_url = ref["url"]

                        vulnerabilities.append(
                            Vulnerability(
                                package=package_name,
                                version=current_version,
                                vulnerability_id=vuln.get("id", "N/A"),
                                severity=severity.upper(),
                                advisory_url=extracted_advisory_url
                            )
                        )
                return vulnerabilities
            except httpx.HTTPStatusError as e:
                logger.error(f"OSV Checker: HTTP error for {package_name} (Status: {e.response.status_code}): {e.response.text}", exc_info=True)
                return []
            except httpx.RequestError as e:
                logger.error(f"OSV Checker: Network error for {package_name}: {e}", exc_info=True)
                return []
            except Exception as e:
                logger.error(f"OSV Checker: Unexpected error fetching data for {package_name}: {e}", exc_info=True)
                return []


async def check_pypi_vulnerabilities(
    package_name: str,
    current_version: str
) -> List[Vulnerability]:
    """
    Checks the PyPI Advisory Database (via PyPI JSON API) for known vulnerabilities
    affecting a specific Python package version.
    """
    vulnerabilities: List[Vulnerability] = []
    pypi_advisory_url = f"https://pypi.org/pypi/{package_name}/json"

    async with vulnerability_api_throttler:
        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(pypi_advisory_url, timeout=10)
                response.raise_for_status()
                data = response.json()

                advisories = data.get("vulnerabilities", [])
                if advisories:
                    logger.info(f"PyPI Checker: Found {len(advisories)} advisories for {package_name} ({current_version}).")
                    current_version_obj = parse_version(current_version)

                    for advisory in advisories:
                        is_vulnerable = False
                        affected_versions_list = advisory.get("affected_versions")

                        if affected_versions_list:
                            for affected_range_dict in affected_versions_list:
                                specifier = affected_range_dict.get("specifier")
                                if specifier:
                                    try:
                                        if current_version_obj in SpecifierSet(specifier):
                                            is_vulnerable = True
                                            break
                                    except Exception as spec_e:
                                        logger.warning(f"PyPI Checker: Error parsing specifier '{specifier}' for {package_name}: {spec_e}", exc_info=True)

                        if is_vulnerable:
                            vulnerabilities.append(
                                Vulnerability(
                                    package=package_name,
                                    version=current_version,
                                    vulnerability_id=advisory.get("id", "N/A"),
                                    severity=advisory.get("severity", "UNKNOWN").upper(),
                                    advisory_url=advisory.get("link", advisory.get("url", "N/A"))
                                )
                            )
                return vulnerabilities
            except httpx.HTTPStatusError as e:
                logger.error(f"PyPI Checker: HTTP error for {package_name} (Status: {e.response.status_code}): {e.response.text}", exc_info=True)
                return []
            except httpx.RequestError as e:
                logger.error(f"PyPI Checker: Network error for {package_name}: {e}", exc_info=True)
                return []
            except Exception as e:
                logger.error(f"PyPI Checker: Unexpected error fetching data for {package_name}: {e}", exc_info=True)
                return []


async def aggregate_vulnerability_results(
    package_name: str,
    current_version: str
) -> List[Vulnerability]:
    """
    Aggregates vulnerability results for a given package from multiple sources
    (PyPI, OSV.dev) and de-duplicates them based on vulnerability_id.
    """
    pypi_vulns_task = check_pypi_vulnerabilities(package_name, current_version)
    osv_vulns_task = check_osv_vulnerabilities(package_name, current_version)

    pypi_vulns, osv_vulns = await asyncio.gather(pypi_vulns_task, osv_vulns_task)

    unique_vuln_ids = set()
    combined_vulns: List[Vulnerability] = []

    for vuln in pypi_vulns:
        if vuln.vulnerability_id not in unique_vuln_ids:
            combined_vulns.append(vuln)
            unique_vuln_ids.add(vuln.vulnerability_id)

    for vuln in osv_vulns:
        if vuln.vulnerability_id not in unique_vuln_ids:
            combined_vulns.append(vuln)
            unique_vuln_ids.add(vuln.vulnerability_id)

    if combined_vulns:
        logger.info(f"VulnerabilityChecker: Aggregated {len(combined_vulns)} unique vulnerabilities for {package_name} ({current_version}).")
    else:
        logger.info(f"VulnerabilityChecker: No vulnerabilities found for {package_name} ({current_version}) from aggregated sources.")

    return combined_vulns